pipeline {
  agent { label 'linux' }

  options {
    disableConcurrentBuilds()
    timestamps()
  }

  parameters {
    choice(name: 'BRANCH', choices: ['release', 'dev', 'main'], description: 'Git branch to build')
    choice(name: 'ACTION', choices: ['apply', 'destroy'], description: 'Terraform action')
    string(name: 'REGION', defaultValue: 'us-east-2', description: 'AWS Region')
    booleanParam(name: 'DEPLOY_OVERRIDE', defaultValue: false,
      description: 'Enable deploy on non-release branches (dev or main)')
  }

  environment {
    AWS_REGION = "${params.REGION ?: 'us-east-2'}"
    GIT_REPO  = 'https://github.com/ndiforfusi/fintech-infra.git'
  }

  tools {
    // keep only if you configured a tool named 'terraform-1.5.0' under Manage Jenkins â†’ Tools
    terraform 'terraform-1.5.0'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout([$class: 'GitSCM',
          branches: [[name: "*/${params.BRANCH}"]],
          userRemoteConfigs: [[url: env.GIT_REPO, credentialsId: 'github-pat']], // <-- set your GitHub creds ID
          extensions: [[$class: 'LocalBranch', localBranch: "${params.BRANCH}"]] // optional: creates local branch
        ])
      }
    }

    stage('Resolve Environment') {
      steps {
        script {
          def branch = params.BRANCH?.trim() ?: 'main'
          def supported = ['dev', 'qa', 'uat', 'main'].contains(branch)
          env.BUILD_SUPPORTED = supported ? 'true' : 'false'

          // Map branch -> Terraform env/dir
          if (branch == 'dev') {
            env.TF_ENV = 'dev'
          } else if (branch == 'qa') {
            env.TF_ENV = 'qa'
          } else if (branch == 'uat') {
            env.TF_ENV = 'uat'
          } else {
            env.TF_ENV = 'prod'
          }
          env.TF_DIR = env.TF_ENV

          // Deploy rules:
          // - dev/qa/uat/main branches are supported
          // - Always require approval for prod
          env.SHOULD_DEPLOY = (supported || params.DEPLOY_OVERRIDE) ? 'true' : 'false'

          echo "Branch=${branch} | Supported=${env.BUILD_SUPPORTED} | TF_ENV=${env.TF_ENV} | TF_DIR=${env.TF_DIR} | SHOULD_DEPLOY=${env.SHOULD_DEPLOY}"
        }
      }
    }

    stage('Verify working directory') {
      steps {
        sh 'echo "Working in ./${TF_DIR}"; ls -la "./${TF_DIR}" || true'
      }
    }

    stage('Terraform Plan') {
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
          dir(env.TF_DIR) {
            sh '''
              terraform fmt -check || true
              terraform init -upgrade -backend-config="key=${TF_ENV}/terraform.tfstate"
              terraform plan -lock=false -input=false -no-color | tee ../plan-${TF_ENV}.txt
            '''
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: "plan-${env.TF_ENV}.txt", fingerprint: true, onlyIfSuccessful: false
        }
      }
    }

    stage('Approval Gate') {
      when {
        allOf {
          expression { env.BUILD_SUPPORTED == 'true' }
          expression { env.SHOULD_DEPLOY == 'true' }
        }
      }
      steps {
        script {
          def message = "Approve deployment to ${env.TF_ENV}?"
          if (env.TF_ENV == 'prod') {
            message = "CRITICAL: Approve PRODUCTION deployment?"
          }
          timeout(time: 2, unit: 'HOURS') {
            input message: message
          }
        }
      }
    }

    stage('Deploy') {
      when {
        allOf {
          expression { env.BUILD_SUPPORTED == 'true' }
          expression { env.SHOULD_DEPLOY == 'true' }
        }
      }
      steps {
        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
          credentialsId: 'aws-creds',
          accessKeyVariable: 'AWS_ACCESS_KEY_ID',
          secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
          dir(env.TF_DIR) {
            script {
              sh 'terraform init -backend-config="key=${TF_ENV}/terraform.tfstate"'
              if ((params.ACTION ?: 'apply').toLowerCase() == 'destroy') {
                sh 'terraform destroy -auto-approve -lock=false -input=false'
              } else {
                sh 'terraform apply -auto-approve -lock=false -input=false'
              }
            }
          }
        }
      }
    }

    stage('Drift Detection') {
      when {
        allOf {
          expression { env.TF_ENV == 'prod' }
          expression { (params.ACTION ?: 'apply').toLowerCase() == 'apply' }
        }
      }
      steps {
        dir(env.TF_DIR) {
          sh 'terraform plan -detailed-exitcode -lock=false || if [ $? -eq 2 ]; then echo "DRIFT DETECTED"; exit 1; fi'
        }
      }
    }

    stage('Plan-only Notice (Unsupported Branch)') {
      when { expression { env.BUILD_SUPPORTED != 'true' } }
      steps {
        echo "Branch ${params.BRANCH} is not in [dev, release, main]. Running plan only; deploy is disabled."
      }
    }
  }

  post {
    always {
      echo "Done: BRANCH=${params.BRANCH} ENV=${env.TF_ENV} DEPLOY=${env.SHOULD_DEPLOY} ACTION=${params.ACTION ?: 'apply'} REGION=${env.AWS_REGION}"
    }
  }
}
